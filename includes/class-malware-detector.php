<?php

if (!defined('ABSPATH')) {
    exit;
}

class WP_AI_Security_Scanner_Malware_Detector {
    
    private $database;
    private $signatures;
    private $confidence_threshold = 0.5;
    private $openai_api_key;
    private $virustotal_api_key;
    private $use_openai = false;
    private $use_virustotal = false;
    
    public function __construct() {
        $this->database = new WP_AI_Security_Scanner_Database();
        $this->signatures = $this->database->get_config('malware_signatures', array());
        
        $settings = get_option('wp_ai_security_scanner_settings', array());
        $this->openai_api_key = isset($settings['openai_api_key']) ? $settings['openai_api_key'] : '';
        $this->virustotal_api_key = isset($settings['virustotal_api_key']) ? $settings['virustotal_api_key'] : '';
        $this->use_openai = isset($settings['use_openai']) ? $settings['use_openai'] : false;
        $this->use_virustotal = isset($settings['use_virustotal']) ? $settings['use_virustotal'] : false;
    }
    
    public function analyze_file($file_path, $content) {
        $threats = array();
        
        // Local analysis methods
        $signature_threats = $this->check_signatures($file_path, $content);
        $heuristic_threats = $this->heuristic_analysis($file_path, $content);
        $ai_threats = $this->ai_analysis($file_path, $content);
        
        // API-based analysis
        $openai_threats = array();
        $virustotal_threats = array();
        
        if ($this->use_openai && !empty($this->openai_api_key)) {
            $openai_threats = $this->openai_analysis($file_path, $content);
        }
        
        if ($this->use_virustotal && !empty($this->virustotal_api_key)) {
            $virustotal_threats = $this->virustotal_analysis($file_path, $content);
        }
        
        $threats = array_merge($signature_threats, $heuristic_threats, $ai_threats, $openai_threats, $virustotal_threats);
        
        return $this->filter_and_score_threats($threats);
    }
    
    private function check_signatures($file_path, $content) {
        $threats = array();
        
        foreach ($this->signatures as $signature_name => $signature_data) {
            if (preg_match($signature_data['pattern'], $content, $matches)) {
                $threats[] = array(
                    'type' => $signature_name,
                    'severity' => $signature_data['severity'],
                    'description' => $signature_data['description'],
                    'confidence' => 0.9,
                    'evidence' => isset($matches[0]) ? substr($matches[0], 0, 200) : '',
                    'line_number' => $this->get_line_number($content, $matches[0])
                );
            }
        }
        
        return $threats;
    }
    
    private function heuristic_analysis($file_path, $content) {
        $threats = array();
        
        $suspicious_functions = array(
            'eval' => 'high',
            'exec' => 'high',
            'shell_exec' => 'high',
            'system' => 'high',
            'passthru' => 'high',
            'file_get_contents' => 'medium',
            'file_put_contents' => 'medium',
            'fopen' => 'medium',
            'fwrite' => 'medium',
            'curl_exec' => 'medium',
            'base64_decode' => 'low',
            'str_rot13' => 'low',
            'gzinflate' => 'medium',
            'gzuncompress' => 'medium'
        );
        
        foreach ($suspicious_functions as $function => $severity) {
            if (preg_match('/\b' . preg_quote($function) . '\s*\(/i', $content, $matches)) {
                $context = $this->get_function_context($content, $matches[0]);
                
                if ($this->is_suspicious_usage($function, $context)) {
                    $threats[] = array(
                        'type' => 'suspicious_function',
                        'severity' => $severity,
                        'description' => "Suspicious usage of function: $function",
                        'confidence' => $this->calculate_function_confidence($function, $context),
                        'evidence' => substr($context, 0, 200),
                        'line_number' => $this->get_line_number($content, $matches[0])
                    );
                }
            }
        }
        
        if (preg_match('/\$_(?:GET|POST|REQUEST|COOKIE)\s*\[.*?\]/', $content, $matches)) {
            $threats[] = array(
                'type' => 'user_input',
                'severity' => 'medium',
                'description' => 'Direct usage of user input without sanitization',
                'confidence' => 0.6,
                'evidence' => substr($matches[0], 0, 200),
                'line_number' => $this->get_line_number($content, $matches[0])
            );
        }
        
        if (preg_match('/(?:include|require)(?:_once)?\s*\(\s*\$/', $content, $matches)) {
            $threats[] = array(
                'type' => 'dynamic_include',
                'severity' => 'high',
                'description' => 'Dynamic file inclusion with variable',
                'confidence' => 0.8,
                'evidence' => substr($matches[0], 0, 200),
                'line_number' => $this->get_line_number($content, $matches[0])
            );
        }
        
        $obfuscation_score = $this->calculate_obfuscation_score($content);
        if ($obfuscation_score > 0.7) {
            $threats[] = array(
                'type' => 'obfuscated_code',
                'severity' => 'medium',
                'description' => 'Heavily obfuscated code detected',
                'confidence' => $obfuscation_score,
                'evidence' => 'High obfuscation score: ' . round($obfuscation_score, 2),
                'line_number' => 0
            );
        }
        
        return $threats;
    }
    
    private function ai_analysis($file_path, $content) {
        $threats = array();
        
        $entropy = $this->calculate_entropy($content);
        $suspicious_patterns = $this->detect_suspicious_patterns($content);
        $behavioral_score = $this->analyze_behavioral_patterns($content);
        
        if ($entropy > 7.5) {
            $threats[] = array(
                'type' => 'high_entropy',
                'severity' => 'medium',
                'description' => 'High entropy content suggesting encryption or obfuscation',
                'confidence' => min(($entropy - 7.5) / 2, 1.0),
                'evidence' => "Entropy score: $entropy",
                'line_number' => 0
            );
        }
        
        foreach ($suspicious_patterns as $pattern) {
            $threats[] = array(
                'type' => 'suspicious_pattern',
                'severity' => $pattern['severity'],
                'description' => $pattern['description'],
                'confidence' => $pattern['confidence'],
                'evidence' => $pattern['evidence'],
                'line_number' => $pattern['line_number']
            );
        }
        
        if ($behavioral_score > 0.6) {
            $threats[] = array(
                'type' => 'malicious_behavior',
                'severity' => 'high',
                'description' => 'Code exhibits malicious behavioral patterns',
                'confidence' => $behavioral_score,
                'evidence' => 'Behavioral analysis score: ' . round($behavioral_score, 2),
                'line_number' => 0
            );
        }
        
        return $threats;
    }
    
    private function calculate_entropy($content) {
        $chars = count_chars($content, 1);
        $length = strlen($content);
        $entropy = 0;
        
        foreach ($chars as $count) {
            $probability = $count / $length;
            $entropy -= $probability * log($probability, 2);
        }
        
        return $entropy;
    }
    
    private function calculate_obfuscation_score($content) {
        $score = 0;
        
        if (preg_match_all('/[a-zA-Z0-9+\/=]{50,}/', $content, $matches)) {
            $score += count($matches[0]) * 0.1;
        }
        
        if (preg_match_all('/\\\\x[0-9a-fA-F]{2}/', $content, $matches)) {
            $score += count($matches[0]) * 0.05;
        }
        
        if (preg_match_all('/str_rot13|base64_decode|gzinflate|gzuncompress/', $content, $matches)) {
            $score += count($matches[0]) * 0.2;
        }
        
        $avg_word_length = strlen($content) / (str_word_count($content) + 1);
        if ($avg_word_length > 20) {
            $score += 0.3;
        }
        
        return min($score, 1.0);
    }
    
    private function detect_suspicious_patterns($content) {
        $patterns = array();
        
        if (preg_match('/\$[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*["\'][^"\']*["\'];\s*\$[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*str_replace/', $content, $matches)) {
            $patterns[] = array(
                'severity' => 'medium',
                'description' => 'String replacement pattern commonly used in malware',
                'confidence' => 0.7,
                'evidence' => substr($matches[0], 0, 200),
                'line_number' => $this->get_line_number($content, $matches[0])
            );
        }
        
        if (preg_match('/\$[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*\$[a-zA-Z_][a-zA-Z0-9_]*\s*\.\s*\$[a-zA-Z_][a-zA-Z0-9_]*/', $content, $matches)) {
            $patterns[] = array(
                'severity' => 'low',
                'description' => 'Variable concatenation pattern',
                'confidence' => 0.4,
                'evidence' => substr($matches[0], 0, 200),
                'line_number' => $this->get_line_number($content, $matches[0])
            );
        }
        
        if (preg_match('/for\s*\(\s*\$[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*0.*?chr\s*\(/', $content, $matches)) {
            $patterns[] = array(
                'severity' => 'high',
                'description' => 'Character building loop commonly used in obfuscation',
                'confidence' => 0.8,
                'evidence' => substr($matches[0], 0, 200),
                'line_number' => $this->get_line_number($content, $matches[0])
            );
        }
        
        return $patterns;
    }
    
    private function analyze_behavioral_patterns($content) {
        $score = 0;
        
        if (preg_match('/wp_users.*password/', $content)) {
            $score += 0.4;
        }
        
        if (preg_match('/admin.*user.*add/', $content)) {
            $score += 0.3;
        }
        
        if (preg_match('/file_get_contents\s*\(\s*["\']https?:\/\//', $content)) {
            $score += 0.2;
        }
        
        if (preg_match('/curl.*exec.*post/i', $content)) {
            $score += 0.3;
        }
        
        if (preg_match('/mail\s*\(.*@.*\)/', $content)) {
            $score += 0.1;
        }
        
        if (preg_match('/\$_SERVER\s*\[\s*["\']HTTP_/', $content)) {
            $score += 0.2;
        }
        
        return min($score, 1.0);
    }
    
    private function filter_and_score_threats($threats) {
        $filtered = array();
        
        foreach ($threats as $threat) {
            if ($threat['confidence'] >= $this->confidence_threshold) {
                $filtered[] = $threat;
            }
        }
        
        usort($filtered, function($a, $b) {
            $severity_order = array('low' => 1, 'medium' => 2, 'high' => 3, 'critical' => 4);
            
            $a_severity = $severity_order[$a['severity']] ?? 0;
            $b_severity = $severity_order[$b['severity']] ?? 0;
            
            if ($a_severity === $b_severity) {
                return $b['confidence'] <=> $a['confidence'];
            }
            
            return $b_severity <=> $a_severity;
        });
        
        return $filtered;
    }
    
    private function get_line_number($content, $needle) {
        $pos = strpos($content, $needle);
        if ($pos === false) {
            return 0;
        }
        
        return substr_count($content, "\n", 0, $pos) + 1;
    }
    
    private function get_function_context($content, $function_call) {
        $pos = strpos($content, $function_call);
        if ($pos === false) {
            return '';
        }
        
        $start = max(0, $pos - 100);
        $end = min(strlen($content), $pos + strlen($function_call) + 100);
        
        return substr($content, $start, $end - $start);
    }
    
    private function is_suspicious_usage($function, $context) {
        switch ($function) {
            case 'eval':
                return preg_match('/eval\s*\(\s*\$/', $context) || preg_match('/base64_decode/', $context);
            
            case 'exec':
            case 'shell_exec':
            case 'system':
                return preg_match('/\$_(?:GET|POST|REQUEST)/', $context);
            
            case 'file_get_contents':
                return preg_match('/https?:\/\//', $context);
            
            case 'base64_decode':
                return preg_match('/base64_decode\s*\(\s*["\'][A-Za-z0-9+\/=]{50,}/', $context);
            
            default:
                return false;
        }
    }
    
    private function calculate_function_confidence($function, $context) {
        $base_confidence = 0.5;
        
        if (preg_match('/\$_(?:GET|POST|REQUEST)/', $context)) {
            $base_confidence += 0.3;
        }
        
        if (preg_match('/base64_decode|str_rot13|gzinflate/', $context)) {
            $base_confidence += 0.2;
        }
        
        if (preg_match('/eval|exec|system/', $context)) {
            $base_confidence += 0.4;
        }
        
        return min($base_confidence, 1.0);
    }
    
    public function update_signatures($new_signatures) {
        $this->signatures = array_merge($this->signatures, $new_signatures);
        $this->database->save_config('malware_signatures', $this->signatures);
        $this->database->save_config('last_signature_update', time());
        
        return true;
    }
    
    public function get_signature_count() {
        return count($this->signatures);
    }
    
    public function set_confidence_threshold($threshold) {
        $this->confidence_threshold = max(0.1, min(1.0, $threshold));
        return $this->confidence_threshold;
    }
    
    private function openai_analysis($file_path, $content) {
        $threats = array();
        
        if (empty($this->openai_api_key)) {
            return $threats;
        }
        
        // Limit content size for API efficiency
        $content_sample = strlen($content) > 4000 ? substr($content, 0, 4000) : $content;
        
        $prompt = $this->build_openai_prompt($file_path, $content_sample);
        
        $response = $this->call_openai_api($prompt);
        
        if ($response && isset($response['analysis'])) {
            $analysis = $response['analysis'];
            
            if (isset($analysis['is_malicious']) && $analysis['is_malicious']) {
                $threats[] = array(
                    'type' => 'openai_detection',
                    'severity' => $this->map_openai_severity($analysis['risk_level'] ?? 'medium'),
                    'description' => $analysis['description'] ?? 'OpenAI detected potential malware',
                    'confidence' => ($analysis['confidence'] ?? 70) / 100,
                    'evidence' => $analysis['evidence'] ?? 'AI analysis',
                    'line_number' => 0,
                    'source' => 'OpenAI'
                );
            }
        }
        
        return $threats;
    }
    
    private function virustotal_analysis($file_path, $content) {
        $threats = array();
        
        if (empty($this->virustotal_api_key)) {
            return $threats;
        }
        
        $file_hash = hash('sha256', $content);
        
        // First, check if file hash is already known
        $vt_response = $this->query_virustotal_hash($file_hash);
        
        if ($vt_response && isset($vt_response['data']['attributes']['last_analysis_stats'])) {
            $stats = $vt_response['data']['attributes']['last_analysis_stats'];
            $malicious_count = $stats['malicious'] ?? 0;
            $total_engines = $stats['malicious'] + $stats['clean'] + $stats['suspicious'] + $stats['undetected'];
            
            if ($malicious_count > 0) {
                $confidence = min(($malicious_count / max($total_engines, 1)) * 1.5, 1.0);
                
                $threats[] = array(
                    'type' => 'virustotal_detection',
                    'severity' => $malicious_count > 5 ? 'critical' : ($malicious_count > 2 ? 'high' : 'medium'),
                    'description' => "VirusTotal detected malware: {$malicious_count}/{$total_engines} engines flagged this file",
                    'confidence' => $confidence,
                    'evidence' => "File hash: {$file_hash}",
                    'line_number' => 0,
                    'source' => 'VirusTotal'
                );
            }
        } else {
            // If hash not found, upload file for analysis (for small files only)
            if (strlen($content) < 650000) { // 650KB limit for VirusTotal
                $upload_response = $this->upload_to_virustotal($content);
                if ($upload_response) {
                    // Note: In production, you'd typically wait and check the analysis results
                    // For now, we'll just log that the file was submitted for analysis
                    error_log("WP AI Scanner: File submitted to VirusTotal for analysis: {$file_path}");
                }
            }
        }
        
        return $threats;
    }
    
    private function build_openai_prompt($file_path, $content) {
        $extension = pathinfo($file_path, PATHINFO_EXTENSION);
        
        return "Analyze this {$extension} file for potential security threats and malware. 

File content:
```
{$content}
```

Please provide your analysis in JSON format with the following structure:
{
    \"analysis\": {
        \"is_malicious\": boolean,
        \"risk_level\": \"low|medium|high|critical\",
        \"confidence\": number (0-100),
        \"description\": \"Brief description of threats found\",
        \"evidence\": \"Specific code patterns or functions that indicate malware\",
        \"threat_types\": [\"array of threat types found\"]
    }
}

Focus on:
- Obfuscated code patterns
- Suspicious function calls (eval, exec, shell_exec, system)
- Base64 encoded payloads
- File inclusion vulnerabilities
- SQL injection patterns
- Backdoor indicators
- Crypto mining code
- Phishing attempts";
    }
    
    private function call_openai_api($prompt) {
        $api_url = 'https://api.openai.com/v1/chat/completions';
        
        $headers = array(
            'Content-Type: application/json',
            'Authorization: Bearer ' . $this->openai_api_key
        );
        
        $data = array(
            'model' => 'gpt-4-turbo-preview',
            'messages' => array(
                array(
                    'role' => 'system',
                    'content' => 'You are a cybersecurity expert specializing in malware analysis. Analyze code for security threats and respond only in valid JSON format.'
                ),
                array(
                    'role' => 'user', 
                    'content' => $prompt
                )
            ),
            'max_tokens' => 1000,
            'temperature' => 0.1
        );
        
        $response = wp_remote_post($api_url, array(
            'headers' => $headers,
            'body' => json_encode($data),
            'timeout' => 30
        ));
        
        if (is_wp_error($response)) {
            error_log('WP AI Scanner OpenAI Error: ' . $response->get_error_message());
            return false;
        }
        
        $body = wp_remote_retrieve_body($response);
        $decoded = json_decode($body, true);
        
        if (isset($decoded['choices'][0]['message']['content'])) {
            $content = $decoded['choices'][0]['message']['content'];
            return json_decode($content, true);
        }
        
        return false;
    }
    
    private function query_virustotal_hash($hash) {
        $api_url = "https://www.virustotal.com/api/v3/files/{$hash}";
        
        $headers = array(
            'x-apikey' => $this->virustotal_api_key
        );
        
        $response = wp_remote_get($api_url, array(
            'headers' => $headers,
            'timeout' => 15
        ));
        
        if (is_wp_error($response)) {
            error_log('WP AI Scanner VirusTotal Error: ' . $response->get_error_message());
            return false;
        }
        
        $status_code = wp_remote_retrieve_response_code($response);
        
        if ($status_code === 200) {
            $body = wp_remote_retrieve_body($response);
            return json_decode($body, true);
        }
        
        return false;
    }
    
    private function upload_to_virustotal($content) {
        $api_url = 'https://www.virustotal.com/api/v3/files';
        
        // Create a temporary file
        $temp_file = wp_tempnam();
        file_put_contents($temp_file, $content);
        
        $boundary = wp_generate_uuid4();
        $headers = array(
            'x-apikey' => $this->virustotal_api_key,
            'Content-Type' => 'multipart/form-data; boundary=' . $boundary
        );
        
        $body = "--{$boundary}\r\n";
        $body .= "Content-Disposition: form-data; name=\"file\"; filename=\"sample.txt\"\r\n";
        $body .= "Content-Type: application/octet-stream\r\n\r\n";
        $body .= $content . "\r\n";
        $body .= "--{$boundary}--\r\n";
        
        $response = wp_remote_post($api_url, array(
            'headers' => $headers,
            'body' => $body,
            'timeout' => 30
        ));
        
        unlink($temp_file);
        
        if (is_wp_error($response)) {
            error_log('WP AI Scanner VirusTotal Upload Error: ' . $response->get_error_message());
            return false;
        }
        
        $body = wp_remote_retrieve_body($response);
        return json_decode($body, true);
    }
    
    private function map_openai_severity($risk_level) {
        switch (strtolower($risk_level)) {
            case 'critical':
                return 'critical';
            case 'high':
                return 'high';
            case 'medium':
                return 'medium';
            case 'low':
            default:
                return 'low';
        }
    }
    
    public function validate_openai_api_key($api_key) {
        $api_url = 'https://api.openai.com/v1/models';
        
        $headers = array(
            'Authorization: Bearer ' . $api_key
        );
        
        $response = wp_remote_get($api_url, array(
            'headers' => $headers,
            'timeout' => 10
        ));
        
        return !is_wp_error($response) && wp_remote_retrieve_response_code($response) === 200;
    }
    
    public function validate_virustotal_api_key($api_key) {
        $api_url = 'https://www.virustotal.com/api/v3/users/' . base64_encode($api_key);
        
        $headers = array(
            'x-apikey' => $api_key
        );
        
        $response = wp_remote_get($api_url, array(
            'headers' => $headers,
            'timeout' => 10
        ));
        
        return !is_wp_error($response) && wp_remote_retrieve_response_code($response) === 200;
    }
}